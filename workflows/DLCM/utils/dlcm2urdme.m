function umod = dlcm2urdme(umod, P, gradquotient, varargin)
%DLCM2URDME Load objects for the dlcm-solver into umod
%   UMOD = DLCM2URDME(UMOD,P,GRADQ) Load essential objects into umod:
%   number of types and quantities from urdme struct
%   private.rp.Species and position mapping P and gradquotient.
%
%   UMOD = DLCM2URDME(UMOD,P,GRADQ,T,SIGMA) Also construct and load
%   curvature operators into umod.solverargs.
%
%   UMOD = DLCM2URDME(UMOD,P,GRADQ,T,SIGMA,HMAX) Specify hmax used for
%   constructing curvature operators.
%
%   Additional input is possible through parameter/value pairs to
%   specify properties to be loaded into the umod:
%
%   Property          Value/{Default}          Description
%   -----------------------------------------------------------------------
%   P                 Ndim-by-Nvoxels matrix   Voxel position
%   gradquotient      Scalar | Nvoxels-by-     Ratio between shared edge
%                     Nvoxels sparse matrix    length to distance between
%                                              neighboring voxels
%   D                 Nvoxels-by-Nvoxels       Discrete Laplacian
%                     matrix {URDME's D}
%   Ne                Nvoxels-by-Nvoxels       Mesh neighbor matrix
%                     matrix
%                     {(D-diag(diag(D))~=0)}
%   Rates             Function returning a     Migration rates potentials
%                     1-by-Nmig cell vector
%                     {@(U,Q,QI,P,t){Q(:,1)}}
%   Drate             Function returning a     Migration rates scaling
%                     1-by-Nmig cell vector
%                     {@(Uf,Ut,Q,QI,P){...
%                     1.*(Uf==1).*(Ut==0)+...
%                     1.*(Uf==2).*(Ut<2)}}
%   T                 m-by-n matrix, see       Mesh triangulation 
%                     INITMESH or meshToPet    connectivity
%   sigma             (Ntypes+1)-by-(Ntypes+1) Surface tension coefficients
%                     symmetric matrix
%   mumod             struct                   URDME umod struct for
%                                              internal states and events
%   maxdt_fun         Function with inputs
%                     @(U, Q, QI, ldata_fun)   Maximum SSA time step
%   ldata_fun         Function returning       Internal event rates
%                     1-by-Nldata cell vector, function
%                     inputs: @(U, Q, QI, Ne)
%   internal_state    {'discr'} | 'cont'       Discrete or continuous
%                                              internal states
%
%   Here Ndim is the number of spatial dimensions and Nvoxels is the
%   number of voxels; Ntypes is the number of cell types in the model
%   and Nldata is the number of complex internal rate functions
%   (regarded by mumod as ldata); Ntime is the number of time stamps
%   where simulation data is saved; Nmig is the number of migration
%   potentials used in the model.
%
%   Example:
%     %% (1) Construct simple mesh
%     Nvoxels = 41;
%     mesh_type = 1;  % cartesian mesh
%     [P,~,T,gradquotient] = basic_mesh(mesh_type,Nvoxels);
%
%     %% (2) Construct simple URDME-struct
%     ntypes = 1; nquants = 1; % need at least one cell type and
%     % one micro-enviroment quantity
%     Dexpr = cell(1,ntypes+nquants);
%     Dexpr(:) = {1};
%     umod = pde2urdme(P,T,Dexpr);
%     % DLCM2URDME requires the species info generated by rparse
%     umod = rparse(umod, {'U1 > 1 > U1+U1', 'Q1 > 1 > Q1+Q1'}, ...
%                   {'U1' 'Q1'}, {}, 'test');
%     umod.u0 = [zeros(ntypes+nquants,Nvoxels^2)];
%
%     %% (3) Load essentials into umod
%     umod = dlcm2urdme(umod, P, gradquotient, [], [], []); 
%
% See also BASIC_MESH, RPARSE, DT_OPERATORS.

% E. Blom 2024-11-26

% load number of types and quantities
spec = umod.private.rp.Species;
ntypes = 0;                       % find number of types and quantities
for n = 1:numel(spec)
  % assumes format 'Q#' for quantity number #
  if ~strcmp(spec{n}(1),'Q')
    ntypes = ntypes + 1;
  end
end
nquants = numel(spec) - ntypes;   % ...the rest is quantities

% defaults
optsdef.D = -umod.D(1:ntypes+nquants:end, 1:ntypes+nquants:end)';
optsdef.Ne = (optsdef.D-diag(diag(optsdef.D))~=0);
optsdef.D = optsdef.D;
optsdef.Rates = @(U,Q,QI,P,t){Q(:,1)};    % pressure-driven migration
optsdef.Drate = @(Uf,Ut,Q,QI,P){1.*(Uf==1).*(Ut==0)+1.*(Uf==2).*(Ut<2)};
optsdef.curv = [];
optsdef.mumod = [];
optsdef.ldata_fun = [];
optsdef.maxdt_fun = [];
optsdef.internal_state = 'discr';

% merge defaults with actual inputs
args = {[]};
if nargin > 6
  args = varargin(4:nargin-3);
end
opts = struct(args{:});
fn = fieldnames(opts);
for i = 1:length(fn)    % merge
  if ~isfield(optsdef,fn{i})
      error('Unrecognized property ''%s''.',fn{i});
  end
  optsdef.(fn{i}) = opts.(fn{i}); % all struct field are cells
end
opts = optsdef;
opts.gradquotient = gradquotient; % finally add gradquotient (no default)

% check correctness of @-functions...
ncells = 10;                              % ... using small dummy inputs
nint = 2;
if ~isempty(opts.mumod)
  nint = nint + (size(opts.mumod.u0,1))/2;  % nr of internal states
end
U = zeros(ncells,1); Q = zeros(ncells,nquants); QI = zeros(ncells,2,nint);
Ne = ones(ncells,ncells);                 % fake neighbouring matrix
rates = opts.Rates(U,Q,QI,P,1);
drate = opts.Drate(U,U,Q,QI,P);
nmig = numel(rates);       % nr of migration potentials
if nmig ~= numel(drate)
  error('Sizes of cell arrays returned by Rates and Drates must be equal')
end
for n = 1:nmig
  if any(size(rates{n}) ~= [ncells,1])
    error('Rates-function returns wrong output size')
  end
  if any(size(drate{n}) ~= [ncells,1])
    error('Drate-function returns wrong output size')
  end
end

if ~isempty(opts.maxdt_fun)
  ldata = opts.ldata_fun(U, Q, QI, Ne);
  for l = 1:numel(ldata)
    if any(size(ldata{l}) ~= [ncells,1])
      error('ldata_fun-function returns wrong output size')
    end
  end
  if ~isscalar(opts.maxdt_fun(U, Q, QI, ldata))
    error('maxdt_fun does not return a scalar')
  end
end

% special case: construct curvature operators and put into opts
if nargin > 3 & ~isempty(varargin{1})
  T = varargin{1};
  if size(P,1) == 2
    [~,~,~,Ax,Ay] = dt_operators(P,T);      % 2D FEM operators
  elseif size(P,1) == 3
    [~,~,~,Ax,Ay,Az] = dt_operators(P,T);   % 3D FEM operators
  end
  [L,M] = assema(P,T,1,1,0);          % unfiltered FEM operators
  sigma = varargin{2};

  % Check sigma symmetry (also implicitly checking data type)
  if ~issymmetric(sigma)
    error('Sigma matrix must be symmetric')
  end

  if nargin > 5
    hmax = varargin{3};
  end
  if isempty(hmax)                    % ignore if == []
    hmax = sqrt(max(sum(M,2)));       % default: hmax = sqrt(max(vol))
  end

  % Curvature operators:
  % cell population / elliptic projection smoothing operator
  e_ell = 0.1;                        % recommended range [0.05,5]
  SLa.X = (M + e_ell*hmax^2*L);

  curv = {'SLa', {SLa.X}, 'M', {M}, 'Ax', {Ax}, 'Ay', {Ay}, ...
    'sigma', {sigma}};
  if size(P,1) == 3   % additional 3D operator
    curv{end+1} = 'Az'; curv{end+1} = {Az};
  end

  opts.curv = {curv};
end

% pack essentials into umod
umod.ldata(:,:) = P;              % needed for Drate and Rates!
umod.gdata(1) = nquants;
umod.gdata(2) = ntypes;

% convert opts back to cell array and place in solverargs
opts = [fieldnames(opts)'; struct2cell(opts)'];
if ~isfield(umod, 'solverargs') % avoid overwriting solverargs
  umod.solverargs = [];
end
umod.solverargs = [umod.solverargs(:), opts(:)]';